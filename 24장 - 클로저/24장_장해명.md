> 참고
> [포이마 웹](https://poiemaweb.com/js-closure)

- 클로저는 함수가 **정의될 때의 렉시컬 환경**을 기억합니다.
- 실행 컨텍스트가 종료되어도, 렉시컬 환경이 **참조되고 있는 한** 메모리에 남아 있게 된다.

1. 렉시컬 스코프
2. 함수 객체의 내부 슬롯 `[[Environment]]`
3. 클로저와 렉시컬 환경
4. 클로저의 활용
5. 캡슐화와 정보 은닉
6. 자주 발생하는 실수

# 1. 렉시컬 스코프

- 스코프 정의 : 식별자가 선언된 위치에 따라 다른 코드에서의 참조 여부를 결정하는 것
- 스코프의 실체 : 실행 컨텍스트의 렉시컬 환경 (객체)
- 스코프 체인 : 렉시컬 환경 객체가 `Outer` (상위 스코프에 대한 참조) 를 통해 상위 렉시컬 환경과 연결되는 것.
  - 즉, 함수의 상위 스코프를 결정한다 = 렉시컬 함수의 `Outer` 에 저장할 참조값을 저장한다
- **렉시컬 스코핑** : 렉시컬 환경의 `Outer` 에 저장할 참조값 (상위 스코프에 대한 참조) 가 함수 정의가 평가되는 시점에,
  함수가 정의된 위치에 따라 결정되는 것

# 2. 함수 객체의 `[[Environment]]`

> 렉시컬 스코핑이 가능한 이유.

```js
function outer() {
  function inner() {
    console.log("I'm Inner");
  }
  inner();
}
outer();
```

- 함수 정의가 평가되서 함수 객체를 생성할 때 자신이 정의된 **위치에 의해 결정된 상위 스코프 참조**를 객체 내부 슬롯 `[[Environment]]` 에 저장한다.

- 함수 객체 생성 : 함수 객체의 `[[Environment]]` → <u>상위 스코프</u> (현재 실행 중인 실행 컨텍스트의 렉시컬 환경의 참조) 저장
- 함수 호출 : 렉시컬 환경 객체가 생성될 때, `Outer` 에 함수 객체의 `[[Envrionment]]` 에 저장된 값이 할당된다.
- 함수 객체는 `[[Environment]]` 에 저장된 상위 스코프를, 자신이 존재하는 한 기억한다.

### [추가] 함수 선언문과 함수 표현식의 차이 : 객체가 만들어지는 시점

```js
// foo(); -> 참조 에리
boo(); // "boo"

// 함수 표현식
const foo = () => {
  console.log("foo");
};

// 함수 선언식
function boo() {
  console.log("boo");
}

foo();
```

- 함수 선언식은 컴파일 단계에서, 함수 정의가 평가되어 함수 객체를 만든다.
  - 호이스팅으로 함수 선언이 끌어올려짐
  - 선언식 이전에 함수를 호출해도 에러가 🙅🏻‍♂️
- 함수 표현식은 런타임 단계에서, 함수 정의가 평가되어 함수 객체를 만들고, 변수가 함수 객체를 참조한다.
  - 런타임 중 **실행 흐름이 해당 함수 표현식에 도달했을 때** 평가된다.
  - 표현식 이전에 함수를 호출하면 에러가 나지만, 평가된 이후에는 호출해도 에러가 🙅🏻‍♂️

> [!Note] 그러나
> 함수 선언식과 함수 표현식 모두 함수가 정의된 위치에 따라 상위 스코프가 결정되는 것은 같다.

# 3. 클로저와 렉시컬 환경

### 클로저

> 외부 함수보다 중첩 함수가 더 오래 유지되어, 중첩 함수가 이미 생명 주기가 종료한 외부 함수의 변수를 참조하는 것.
> → 쉽게 말해, 자신의 상위 스코프를 기억하는 특성.

```js fold title="inner 함수는 outer 의 스코프에 접근할 수 있는 클로저"
const x = 1;

function outer() {
  const x = 10;
  const inner = function () {
    console.log(x);
  };
  return inner; // outer( ) 는 inner 함수 객체를 반환
}

const innerfunc = outer(); // 반환된 iiner 함수 객체 참조
innerfunc(); // 사실상 inner( ) 실행

// inner( ) 에서 식별자 X 검색하는 과정
// 1. 자신의 스코프 내에서 검색 : X
// 2. 상위 스코프 (outer) 에서 검색 : x = 10
// 3. 10 출력
```

- `outer( )` 의 실행 컨텍스트는 실행 컨텍스트 스택에서 `pop` 되어 제거되지만, `outer` 의 함수 렉시컬 환경 객체까지 소멸하지는 않는다 → `inner( )` 함수 객체의 `[[Environment]]` 에서 참조되고 있기 때문

> [!danger] 가비지 컬렉션
> 가비지 컬렉터는 누군가가 (여기서는 `inner` ) 참조하고 있는 메모리 공간을 함부로 해제하지 않는다.

- 외부 함수 (`outer`) 보다 더 오래 생존한 중첩 함수 (`inner`) 는 외부 함수의 실행 컨텍스트의 존재 여부와 상관 없이,
  자신이 **정의된 위치에 의해 결정된 상위 스코프를 기억하고, 참조하고, 변경** 할 수 있다.

### 모든 함수는 클로저 ?

> 자바스크립트의 모든 함수는 객체가 만들어질 때 `[[Environment]]` 슬롯에 상위 스코프 참조가 할당된다.
> 즉, 모든 함수는 상위 스코프를 기억한다.

> 🤔 그럼 모든 함수 = 클로저라고 불러도 될까 ?
> 🙅🏻‍♂️상위 스코프의 어떤 식별자도 참조하지 않는다면, 기억하는 것 자체가 메모리 낭비이므로
> 모던 브라우저에서는 최적화를 통해, 상위 스코프를 기억하지 않는다

```js fold title="클로저가 아닌 boo 함수"
// bar 함수의 상위 스코프는 foo, 그러나 foo 에서 참조하고 있는 식별자가 없음
function foo() {
  const a = 1;
  const b = 2;

  function bar() {
    const c = 3;
    console.log(c);
  }
  return bar;
}

const bar = foo(); // 반환된 bar 함수 객체를 참조
bar();
```

### 클로저 결론

**외부 함수보다 중첩 함수가 더 오래 유지**되면서, **외부 함수 (상위 스코프) 의 식별자를 참조**할 때 ‘중첩함수’

# 4. 클로저의 활용

클로저는 상태가 의도치 않게 변경되는 일이 없도록 은닉하고,
특정 함수만 상태 변경을 할 수 있도록 허용할 때 사용한다.

# 5. 캡슐화와 정보 은닉

> _캡슐화 : 객체의 프로퍼티와 메서드를 하나로 묶는 것 정보 은닉 : 캡슐화를 프로터니나 메서드를 감출 목적으로 사용함 → 장점 : 외부로부터 객체 상태가 변경되는 것을 방지, 객체 간 의존도를 낮출 수 있음_

- 자바 등 객체 지향 언어는 `private` , `public` , `protected` 접근 제한자로 클래스의 공개 범위를 한정한다.
- 최신 자바스크립트에서는 `class` 에 `#` 를 사용해 private field 를 정의할 수 있습니다.
  ```jsx
  class Person {
    #name; // private 필드 정의

    constructor(name) {
      this.#name = name; // 생성자에서 초기화
    }

    getName() {
      return this.#name;
    }
  }

  const person = new Person("Tom");
  console.log(person.getName()); // Tom
  ```

# 6. `let`/ `const` 와 렉시컬 환경

![](https://i.imgur.com/kLpc6mh.png)

- 블록 스코프를 가지는 `let` , `const` 를 사용하면 반복문이 실행될 때마다 새로운 렉시컬 환경이 생성된다.
- `let`, `const` 로 초기값을 선언하고 반복문 내부에 함수를 정의할 경우, 함수는 매번 만들어지는 새 렉시컬 환경을 참조한다 => 각 반복에서 생성된 i 상태가 스냅숏처럼 저장된다.
- 내부에 함수가 없다면 ?
  - `i=0` , `i=1` , .. 일 때 새로운 렉시컬 환경이 만들어지는 건 같지만, 반복될 때 렉시컬 환경은 참조되지 않는다 → GC 가 제거한다.
