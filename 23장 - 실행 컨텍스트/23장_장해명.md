# 실행 컨텍스트 정리

> 모든 렉시컬 환경은 Record (환경 레코드) 와 Outer (외부 렉시컬 환경에 대한 참조) 로 이루어진다 - 렉시컬 환경의 정의 : 식별자, 식별자에 바인딩된 값, 상위 스코프에 대한 참조를 기록하는 자료구조
>
> `this` 바인딩은 전역 환경 레코드, 함수 환경 레코드에만 존재한다.
>
> 전역 코드 안에 함수가 있을 때, 함수가 호출되면 전역 코드의 실행을 일시 중단하고
> 함수 내부로 코드의 제어권이 이동한다. 그리고 함수 코드를 평가하고, 실행한다.
>
> **함수 정의가 평가되는 시점은 컴파일 단계**이다.
> 함수가 전역 코드나, 다른 함수 안에서 정의가 되었다면 자바스크립트 엔진은 함수 객체라는 걸 만들고, 이 객체를 렉시컬 환경에 등록한다. 컴파일에서는 함수 이름만 렉시컬 환경에 등록되는 것
> `function foo(a) { console.log(a); }` → `foo` 이름을 가진 함수 객체가 만들어지고, 전역 렉시컬 환경에 등록된다.
> **함수 코드가 평가되고 실행되는 시점은 런타임 단계**이다.

1. **전역 코드 평가**는 컴파일 단계에서 이루어진다.
   - 비어 있는 전역실행컨텍스트를 만들어서 스택에 푸쉬
   - 전역 렉시컬 환경을 만들고, 전역실행컨텍스트에 바인딩
     - 전역 환경 레코드 → 객체 환경 레코드 + 선언적 환경 레코드 + `[[GlobalThisValue]]` 에 전역객체 (window, global)
     - 상위 스코프 참조 → `null` (전역 코드를 포함하는 소스코드는 없음) 설정됨 (더이상 참조할 상위 스코프가 없음)
2. **전역 코드 실행**은 런타임에 이루어진다.
3. **함수가 호출되는 순간, 평가 → 곧바로 실행**으로 넘어간다 (함수의 평가와 실행은 모두 런타임에서 처리됨)
   - **함수 평가**
     - 실행 컨텍스트를 생성하지만, 비어있는 상태로 푸쉬는 하지 않는다.
     - 함수 렉시컬 환경이 완성되고 바인딩되면, 실행 컨텍스트 콜스택에 푸쉬한다.
       - **함수 환경 레코드**
         → <매개변수, `arguments` 객체, 함수 내부에서 선언한 지역변수와 중첩함수>
         → `[[ThisValue]]` 에 `this` 가 바인딩 : 함수가 어떻게 호출되었는지에 따라 다름
       - **상위 스코프에 대한 참조** (외부 렉시컬환경에 대한 참조) 🙆🏻
         → 함수 정의가 평가된 시점의 실행 중인 실행 컨텍스트의 렉시컬 환경을 참조한다
         (쉽게 말해, 자신이 정의된 위치의 렉시컬 환경이 설정된다 = `foo( )` 가 전역 함수라면, 전역 렉시컬 환경이 설정됨)
   - **함수 실행** : 소스코드를 순차적으로 실행한다.
4. 함수 실행 종료 → 더 이상 실행할 코드가 없다면 함수 실행이 종료된다.
   - 실행 컨텍스트 스택에서 해당 함수 컨텍스트 가 `pop` 으로 제거된다.
   - 함수의 렉시컬 환경은 **독립적인 객체** 로 존재하기 때문에, 누군가가 참조하고 있다면 메모리에서 해제되지 않는다
     (클로저와의 연관성 )
     (외부 함수의 렉시컬 환경은, 중첩 함수가 참조를 유지하는 한 가비지 컬렉터가 해제시키지 않는다)
     (함수의 렉시컬 환경이 소멸하는 시점 : 아무도 참조하지 않아서 가비지 컬렉터에 의해 메모리에서 해제될 때)

> **함수환경 레코드의 Outer 에 어떻게, 자신이 정의된 위치의 렉시컬 환경이 설정되는걸까?** 🙆🏻
> → **렉시컬 스코핑 (동적 스코핑) 이 구현되는 메커니즘 = 함수 객체의 `[[Environment]]`**
> ‘함수 정의가 평가되는건 컴파일, 함수 환경 레코드가 만들어지는 건 런타임이다.
> 그럼 함수 환경 레코드는 컴파일 단계에서 일어났을 일을 어떻게 알고있는 걸까?’
>
> 자바스크립트 엔진은 컴파일 단계에서 함수 정의를 평가할 때 함수 객체를 만든다.
> 객체를 만들 때 ‘현재 실행중인 실행 컨텍스트의 렉시컬 환경’ (함수의 상위 스코프) 을 객체 내부 슬롯 `[[Environment]]` 에 저장한다. 위에서 나온 `Outer` (외부 렉시컬환경에 대한 참조) 에 할당되는 게, 함수 객체 `[[Environment]]` 에 저장된 값이다.

### 스코프 체인

> 현재 실행 중인 실행 컨텍스트의 렉시컬 환경에서 시작해 외부 렉시컬 환경에 대한 참조로 이어지는, 렉시컬 환경의 연속

`console.log( )` 의 `console` 식별자를 찾는 과정

- 식별자는 스코프 체인에서 검색한다 → 언제나 현재 실행 중인 실행 컨텍스트의 렉시컬 환경에서 검색한다.
  → 식별자가 없는 경우 스코프 체인을 타고 올라가 상위 스코프 (자신의 외부 렉시컬 환경에 대한 참조가 가리키는) 로 이동해서 검색한다 … → 전역 렉시컬 환경에서 객체 환경 레코드의 BindingObject - 전역 객체에서 찾을 수 있다.

`console.log( )` 의 `log( )` 를 찾는 과정

- `console` 객체에서 프로토타입 체인을 통해 메서드를 검색한다.

`console.log(a+b..)` 의 `a`, `b` .. 식별자를 찾는 과정

- 역시 스코프 체인에서 검색한다.

### 블록 레벨 스코프

> 핵심 : 블록이 실행되면, 새로운 렉시컬 환경이 생성되어 활성화되고 기존 렉시컬 환경은 `Outer` 로 남아있음
> 책에서 말하는 ‘교체’ 는, 활성화된 렉시컬 환경이 변경되는 것을 의미함.
> 주의 : 블록은 함수 호출과 달리, 렉시컬 환경 안에서만 관리되므로 실행 컨텍스트 콜스택에는 영향을 주지 못함
> 즉, 실행 중인 실행 컨텍스트는 계속 기존 실행 컨텍스트임.

1. `{}` 이 실행되면 ‘선언적 환경 레코드’ 를 가지는 렉시컬 환경이 새로 생성된다.
   (렉시컬 환경의 `Outer` 는 기존 렉시컬 환경을 참조한다)
2. 실행 컨텍스트에서 **활성화된 렉시컬 환경**이 기존 → 생성된 렉시컬 환경으로 ‘교체’ 된다
   (하지만 기존 렉시컬 환경은, 새 렉시컬 환경의 `Outer` 로 유지되고 있는 상태)
3. 블록이 종료되는 순간, 블록 렉시컬 환경이 제거되고 → 다시 기존 렉시컬 환경이 활성화된다.

```js
const a = 3;

{
  let b = 5;
  console.log(b);
}

console.log(a);
```

> **내가 정리한 과정**
> 전역 실행 컨텍스트 생성되고 푸쉬, 전역 렉시컬 환경이 바인딩됨
> → `{}` 에 진입하며 블록 실행, 새로운 렉시컬 환경이 생성되고 활성화됨,
> 기존 전역 렉시컬 환경은 해당 렉시컬 환경의 `Outer` 로 참조됨
> → 블록 종료
> → 블록 렉시컬 환경 제거됨
> → 다시 기존 전역 렉시컬 환경이 활성화됨

> **정리**
>
> - `{}` 에 진입할 떄 활성화되는 렉시컬 환경이 전환되지만, 실행 컨텍스트 콜 스택에는 변화가 없다
> - 블록은 새로운 렉시컬 환경을 만들고 기존 환경을 `Outer` 로 참조하지만, 실행 컨텍스트 자체는 여전히 기존 실행컨텍스트다.

### 예제 코드

> 1. 전역 객체 생성
> 2. 전역 코드 평가
> 3. 전역 코드 실행
> 4. foo( ) 함수 코드 평가 – foo ( ) 호출
> 5. foo( ) 함수 코드 실행
> 6. bar( ) 함수 코드 평가 - bar( ) 호출
> 7. bar( ) 함수 코드 실행
> 8. bar( ) 함수 코드 종료
> 9. foo( ) 함수 코드 종료

<br/>

# 🚀

## 전역 객체 실행 ~ 전역 코드 실행 이전까지 과정

1. 제일 먼저 전역 객체가 생성된다.
2. 소스코드가 로드 되면, 자바스크립트 엔진은 전역 코드를 평가한다.
   - 전역 실행 컨텍스트 생성
   - 전역 렉시컬 환경 생성 (렉시컬 환경은 환경레코드(Record) 와 외부 렉시컬 환경에 대한 참조 (Outer) 로 이루어짐)
     - 전역 환경 레코드 : 두 레코드가 서로 협력해 전역 스코프, 전역 객체를 관리한다
       - 객체 환경 레코드 (Object Environment Record) : `var` 로 선언한 전역 변수, 함수 선언문으로 정의한 전역 함수, 빌트인 전역 프로퍼티와 전역 함수, 표준 빌트인 객체
       - 선언적 환경 레코드 (Declarative Environment Record) : `let` , `const` 로 선언한 전역 변수를 관리
       - `this` 바인딩 : 내부 슬롯 `[[GlobalThisValue]]` 에 전역 객체를 바인딩 => 전역 코드에서 `this` 를 참조하면 전역객체 (window, global) 이 나오는 이유
3. 전역 코드를 실행한다.

### 전역 환경 레코드의 두 가지 레코드

#### 객체 환경 레코드

- 전역 환경 레코드는 객체 환경 레코드, 선언적 환경 레코드로 구성되어 있다.
- 객체 환경 레코드도 컴포넌트인데, `BindingObject` 라고 부르는 객체와 연결된다.
  - _BindingObject : 제일 먼저 생성되었던 전역 객체_
- 전역 코드가 평가될 때, `var` 로 선언한 전역 변수와 함수 선언문으로 정의한 전역 함수는, 전역 환경 레코드의 객체 환경 레코드에 연결된 `BindingObject` 를 통해 전역 객체의 프로퍼티와 메서드가 된다. => _전역 객체의 프로퍼티와 메서드가 되기 때문에, 식별자 (window) 없이 전역 객체 프로퍼티를 참조할 수 있는 메커니즘_

```js
var x = 1;
const y = 2;

function foo (a) {
	...
}
```

전역 코드 평가 시점에, 객체 환경 레코드에 바인딩 된 BindingObject 를 통해 전역 객체에 변수 식별자를 키로 등록하고,
암묵적으로 undefined 를 반환한다.
함수 선언문으로 정의된 함수가 평가될 떄도 같다. 위에서는 `foo` 라는 식별자를<u> 전역객체에 키로 등록</u>하고, 생성된 함수 객체를 즉시 할당한다. 그래서 함수 선언문으로 정의된 함수는 선언문 이전에도 호출할 수 있는 것이다.

- 전역 객체에 키로 등록하는 과정 : 객체 환경 레코드에 바인딩된 Binding Object 를 통해 전역 객체에 키로 등록

#### 선언적 환경 레코드

> `let` 과 `const` 로 선언한 전역 변수를 등록하고 관리

## 전역 코드 실행

- 식별자 결정을 위해, <u>실행 중인 실행 컨텍스트</u>에서 식별자를 검색하기 시작한다.
  - => 실행 컨텍스트 스택의 최상위에 위치
- 식별자는 어디에 등록되어 있을까 ?
  - => 실행 컨텍스트의 렉시컬 환경의 환경 레코드
- 실행 중인 실행 컨텍스트에서 찾을 수 없으면 → 상위 스코프 (외부 렉시컬 환경에 대한 참조) 로 이동해서 식별자를 검색한다.
  - => 식별자를 검색하는 과정이 실행 컨텍스트 콜 스택에서 위 → 아래로 이동 ?? #질문 (스코프 체인의 동작 원리)
  - 전역 렉시컬 환경은, 스코프 체인의 종점이다. 즉, 여기서 검색할 수 없는 식별자는 <u>코드 상 아예 존재하지 않는 식별자이므로 </u>참조에러가 난다.

## 함수 호출 : 평가와 실행

- 함수가 호출되면, 전역 코드의 실행을 일시 중단하고 함수 내부로 코드의 제어권이 이동한다.
- 그리고 함수 코드 평가를 시작하는데, 과정은 다음과 같다

1. 함수 실행 컨텍스트 생성
2. 함수 렉시컬 환경 생성 :
   2-1) 함수 환경 레코드 생성 : 매개변수, `arguments` 객체, 함수 내부 선언된 지역변수와 중첩함수
   2-2) `this` 바인딩 : (예제 코드 23-08 : `foo( )` 가 일반함수로 호출되었으므로 `this` 는 전역 객체)
   2-3) 외부 렉시컬 환경에 대한 참조 결정

🙅🏻 함수 실행 컨텍스트는 생성된 직후 바로 스택에 푸쉬되는 것이 아니라
함수 렉시컬 환경이 완성된 시점에 실행 컨텍스트 스택에 푸쉬된다.
(전역 실행 컨텍스트와 다름)

🙆🏻**arguments 객체** - 함수에 전달된 모든 인수들을 index 와 매핑한 객체로, 자동으로 생성된다

```js fold title="arguments 객체 예시"
function foo(a, b) {
  let c = a + b;
}
foo(2, 3);
// Arguments : {0:2, 1:3, length: 2}
```

- 아래처럼 함수 환경 레코드가 만들어진다.

|                |                                     |
| -------------- | ----------------------------------- |
| x (매개변수)   | undefined                           |
| arguments      | { 0 : 20, length : 1, callee : foo} |
| b (var 선언)   | undefined                           |
| c (const 선언) | `<uninitialized>`                   |
| bar (함수)     | `<function object>`                 |

- 여기서 `<uninitialized>` 는 초기화가 되지 않아 변수에 접근할 수 없음을 의미한다. 실제로 이런 값이 바인딩이 된건 아님
