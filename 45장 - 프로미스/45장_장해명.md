# 비동기 처리를 위한 콜백 패턴의 단점

> 1장에서는 Promise 가 등장하게 된 배경을 설명한다.
> 새로운 기술의 등장은, 기존 기술이 가지고 있는 문제점을 해결하기 위해서라는 목적성을 띈다.
> Promise 는 기존 비동기 처리를 위한 콜백 패턴이 가진 문제점인 ’ 콜백 헬 ‘ 과 ‘ 에러 처리의 한계’ 를 해결하기 위해 등장했다.

### 콜백 헬

- 비동기 함수는 비동기 처리 결과 (서버 응답) 에 대한 후속 처리도 비동기 함수 내부의 콜백 함수가 수행한다.
  - 이유 : 비동기 함수는 처리 결과를 외부에 반환할 수도, 상위 스코프의 변수에도 할당할 수 없기 때문임
- 비동기 처리 결과를 가지고 또 다시 비동기 함수를 호출할 때, 콜백 함수 호출이 중첩된다 → ‘콜백 헬’ 이라고 부른다

### 에러 처리의 한계

> 에러는 호출자 (caller) 방향으로 전파된다 = 콜 스택의 아래 방향 (실행 중인 실행 컨텍스트 → 해당 실행 컨텍스트가 푸쉬되기 이전 실행 중이던 실행 컨텍스트 방향)

```js
try {
	setTimeout(() => { thorw new Error("에러"); }, 1000);
} catch (e) {
	// try 문에서 생긴 에러를 캐치하지 못한다
	console.error(e);
}
```

1. `setTimeout( )` 비동기 함수 호출
2. `setTimeout( )` 실행 컨텍스트 생성, 콜스택에 푸쉬, 실행
3. 비동기 함수 이므로 콜백 함수가 호출되는 걸 기다리지 않고 즉시 종료되므로, 콜스택에서 제거됨
4. `setTimeout( )` 의 콜백함수 `() => { ... }` 가 실행됨 (그러나 setTimeout 함수는 이미 콜스택에서 제거된 상태)

→ 콜백함수에서 에러를 반환하더라도, `setTimeout( )` 의 실행 컨텍스트가 이미 제거된 상태이므로 `catch` 문에서 에러가 캐치되지 않는다.

> 위 문제를 해결하기 위해 ES6 에서 Promise 가 도입되었다.

# 프로미스의 생성

> _비동기 처리 상태와 처리 결과를 관리하는 객체_
> → `[[PromiseStatue]]` 와 `[[PromiseValue]]`

- 프로미스 생성자 함수를 `new` 와 함꼐 호출하면 Promise 객체를 반환한다.
  - 생성 직후 Promise 상태는 `pending` (default)
- 프로미스 생성자 함수는 <비동기 처리를 수행할 콜백 함수> 를 인수로 전달받고, 해당 <콜백함수> 는 `resolve( )` 와 `reject( )` 를 인수로 전달받는다.
- 작동 방식

  - `Promise` 생성자 함수가 콜백 함수 내부에서 비동기 처리를 수행한다.
    - 성공 → 인수로 전달받은 `resolve( )` 를 호출 => Promise 상태가 `fullfilled` 로 변경
    - 실패 → 인수로 전달받은 `reject( )` 를 호출 => Promise 상태가 `rejected` 로 변경

- 프로미스 객체의 구성
  - `[[PromiseStatue]]` : 비동기 처리 이후 Promise 의 상태를 저장
  - `[[PromiseValue]]` : 비동기 처리 이후 결과를 저장

### `resolve(value)` 와 `reject(error)`

> 둘다 Promise

- `resolve(value)` : Promise 상태를 `fulfilled` 로 변경하고, value 를 `.then( )` 으로 전달한다.
  이 때 value 는 어떤 값이든 가능하지만, 딱 하나의 값만 전달할 수 있다고 함.
- `reject(error)` : Promise 상태를 `rejected` 으로 변경한다. 주로 `Error` 객체를 전달하지만, 다른 값도 가능하다고 함.

### 프로미스 기본 코드

```jsx fold title="프로미스 기본 구조"
const promise = new Promise((resolve, reject) => {
  // 비동기 처리를 수행하는 콜백함수
  if(/*비동기 처리 성공*/){
    resolve( ); // 객체를 반환
  } else {
    /* 비동기 처리 실패*/
    reject('실패한 이유');
  }
});
```

### 프로미스 응용 코드

```js fold title="Promise 과 getCurrentPositon 을 함께 사용"
const getCurrentLocation = () => {
  return new Promise((resolve, reject) => {
    // 내부적으로 성공 / 실패 처리에 따라 자동으로 콜백을 실행행
    navigator.geolocation.getCurrentPosition(
      (position) => {
        resolve({
          lat: position.coords.latitude,
          lon: position.coords.longitude,
        });
      },
      (error) => reject(error)
    );
  });
};
```

```js fold title="수정한 내 코드 : 오류"
const getCurrentLocations = () => {
  return new Promise((resolve, reject) => {
    navigator.geolocation.getCurrentPosition(
      (position) => {
        if(position){
          resolve(
				lat = position.coords.latitude,
				lon = position.coords.longitude
			)
          )} else {
            (error) => reject(error);
          }
      }
    )
  })
}
getCurrentLocations();
```

> **수정한 코드가 잘못된 이유**
> 애초에 position 이 정상적으로 들어왔을 때 resolve 가 호출되고,
> 에러가 나면 (error) => reject(error) 가 호출되게 해야 한다.
> 즉, 1) 조건문을 사용할 필요가 없다.
>
> 2. `resolve( )` 는 하나의 값만 받을 수 있다.
>    전달할 값이 여러 개라면, 객체나 배열로 묶어야 한다.

**“조건문을 사용하지 않아도 되는 이유”**
먼저 `getCurrentPosition` 의 구조를 이해해야 한다.
우리가 Promise 를 사용할 때는, 일반적으로 `resolve` 와 `reject` 를 조건문에서 직접 호출하지만, `getCurrentPosition` 는 성공과 실패를 구분해서 자체적으로 콜백을 호출하므로, 굳이 조건문을 쓸 필요가 없다.

```js
// 첫번째 인자 : 위치를 가져오는데에 성공하면 실행되는 콜백함수
// 두번째 인자 : 위치를 가져오는데에 실패하면 실행되는 콜백함수
navigator.geolocation.getCurrentPosition(successCallback, errorCallback);

// 실제 코드
navigator.geolocation.getCurrentPosition(
  // 성공시 resolve 를 호출
  (position) => {
    resolve();
  },
  // 실패 시 reject 를 호출
  (error) => reject(error)
);
```

# 프로미스의 후속 처리 메서드와 에러처리

> `.then( )` , `.catch( )`, `.finally( )`
> → _셋의 공통점 : 언제나 프로미스를 반환한다_

### `then( )`

- 전달받는 인수 (2개)
  - 비동기 처리가 성공했을 때 호출되는 성공 처리 콜백 함수
    (Promise 상태가 `fullfilled` 일 때 호출되는 처리 콜백함수)
  - Promise 상태가 `rejected` 일 때 호출되는 처리 콜백함수
- 호출되고 나면 새로운 프로미스 객체가 반환된다 => 여러 개 프로미스를 연결하는 프로미스 체이닝이 가능한 이유

```js fold title="then( ) 을 이용한 프로미스 체이닝"
function getData() {
  return new Promise({
    // ...
  });
}

// then() 으로 여러 개의 프로미스를 연결한 형식
getData()
  .then(function (data) {
    // ...
  })
  .then(function () {
    // ...
  })
  .then(function () {
    // ...
  });
```

### `catch( )`

- 전달받는 인수 (1개)
  - Promise 상태가 `rejected` 일 때 호출되는 처리 콜백함수
- 역시나 호출 후에 새로운 프로미스 객체를 반환한다.

> ❌ **프로미스의 에러 처리 방법 두 가지**
>
> 1. `then( )` 의 두 번째 인자로 에러 처리하기
> 2. `catch( )` 에서 받는 인자로 처리하기 => 이 방법을 더 추천함

### finally( )

- 전달받는 인수 (1개) : Promise 상태와 상관없이 무조건 한번 호출된다.
- **항상 공통적으로 수행해야 하는 내용이 있을 때 사용하면 유용하다.**
- 역시나 호출 후 새로운 프로미스 객체를 반환한다.

### 에러 처리는 `catch( )` 사용하기

- `.then( )` 의 두번째 콜백함수로 에러를 처리할 수도 있지만, 첫 번째 콜백함수에서 발생한 에러를 캐치하지 못한다.
- `.catch( )` 를 모든 then 메서드를 호출한 이후 호출시, 비동기 처리에서 발생한 에러 (rejected 상태) 와 then( ) 내부에서 발생한 에러까지 모두 캐치할 수 있다.

# 프로미스 체이닝

> _후속 처리 메서드 `.then` , `.catch` , `.finally` 가 모두 Promise 객체를 반환하므로 연속적으로 호출할 수 있는 현상_

- 후속 처리 메서드들은 모두 내부에서 콜백 함수가 반환하는 새로운 `Promise` 를 반환한다.
- `Promise` 가 아닌 값이 반환되더라도, 암묵적으로 Promise 를 다시 생성해서 반환한다.
- **Callback Hell 의 해결책**
  - 프로미스 체이닝으로, 비동기 처리 결과를 전달받아 후속처리를 하므로 콜백 함수가 중첩되는 콜백 헬이 일어나지 않는다.
  - 한계 : 그러나, <u>콜백 패턴</u>을 사용하는 것은 같다 (가독성이 좋지 X)
    - async / await (ES8) 로 해결 가능함 : 후속 처리 메서드 없이도, 프로미스가 비동기 처리 결과를 동기적으로 처리하는 것처럼 보이게 코드를 짤 수 있다.

> 🚀**문제 해결 과정**
> 콜백 헬 → <u>후속 처리 메서드를 이용한 프로미스 체이닝</u> → 콜백 패턴 문제
> → <u>async / await 으로 동기 처리처럼 보이도록 함 </u>

# 프로미스의 정적 메서드 5가지

- `Promise.resolve( )` , `Promise.reject( )` : 값을 래핑해 프로미스를 생성함
  - `Promise.resolve( )` : 인수로 전달받은 값을 resolve 하는 프로미스를 생성
  - `Promise.reject( )` : 인수로 전달받은 값을 reject 하는 프로미스를 생성

> 공통점 : 프로미스를 요소로 갖는 이터러블 (배열) 을 전달 받음

| 정적 메서드           | 차이점                                                                                                |     |
| --------------------- | ----------------------------------------------------------------------------------------------------- | --- |
| Promise.all( )        | 전달 받은 모든 프로미스가 `fullfilled` 되면<br>모든 처리 결과를 배열에 저장해, 새로운 프로미스를 반환 |     |
| Promise.race( )       | 가장 먼저 `fullfilled` 된 프로미스 처리 결과를<br>resolve 하는 새로운 프로미스를 반환                 |     |
| Promise.allSettled( ) | 전달 받은 모든 프로미스가 `settled` 되면<br>모든 처리 결과를 배열에 저장해, 새로운 프로미스를 반환    |     |

- Promise.all( )

  - 처리 순서 보장이 필요할 때 : 프로미스가 fullfilled 되는 순서와 상관 없이, 전달 받은 배열에서 요소의 순서에 따라 처리 결과를 저장한다
  - 전달 받은 프로미스 중 하나라도 rejected 가 되면 다른 프로미스들을 기다리지 않고, 즉시 종료한다.
  - _전달 받은 배열의 요소가 프로미스가 아닌 경우, Promise.resolve( ) 로 프로미스로 래핑한다_ #질문

- Promise.race( )
  - 전달 받은 프로미스 중 하나라도 rejected 가 되면 다른 프로미스들을 기다리지 않고, 즉시 종료한다.

# Microtask Queue

```js
// 태스크 큐에 저장
setTimeout( () => console.log(1), 0);

// 마이크로태스크 큐에 저장
Promise.resolve()
	.then(() => console.log(2));
	.then(() => console.log(3));

// → 출력 결과 : 2 3 1
```

- 프로미스의 후속 처리 메서드 (`.then` ) 의 콜백 함수는 마이크로태스크 큐에 저장된다 (우선순위 높음)
- 비동기 함수의 콜백 함수 (`setTimeout( )` 의 콜백) , 이벤트 핸들러는 태스크 큐에 저장된다.

> 🔔**마이크로 태스크 큐 > 태스트 큐 우선순위**
> 이벤트 루프는 콜 스택이 비면, 마이크로 태스큐에서 대기하는 함수를 가져와 먼저 실행하고
> → 이후 마이크로태스트 큐가 비면 태스크 큐에서 함수를 가져와 실행한다.

# fetch 함수

> Promise 를 지원하며 HTTP 요청 전송 기능을 제공하는 Client Side Web API

```js
// 두 번쨰 매개 변수는 선택적
const promise = fetch(url, [, options]);
// 예시
fetch("https://example.com", { method: "POST" });
```

- HTTP 응답을 나타내는 Response 객체를 매핑한 프로미스를 반환한다.
- 이후 `.then( )` 을 통해 resolve 된 Response 객체를 전달받을 수 있다.

```js
fetch("url")
  // response : HTTP 응답이 담긴 Reponse 객체
  // json( ) 로 json 형식으로 데이터를 변환
  .then((response) => response.json());
```

### fetch 의 에러 처리의 한계

- `fetch( )` 가 반환하는 `Promise` 는 네트워크 장애 (오프라인), CORS 에러일 때만 `reject`한다.
- **4XX, 5XX HTTP Error** → `ok` 상태를 `false` 로 설정한 Response 객체를 `resolve` 함
  - `response.ok` 를 조건문에서 확인하고, 개발자가 직접 예외 처리를 해야 한다.

```js
fetch(wrongUrl)
  .then((res) => {
    if (!res.ok) throw new Error(res.statusText);
    return res.json();
  })
  .catch((err) => console.error(err));
```

- 해결책 : `axios` 를 사용한다

  - 모든 HTTP 에러를 reject 하는 Promise 를 반환한다.

   <br/>


> 추가 참고 문헌
> [캡틴판교의 자바스크립트 Promise](https://joshua1988.github.io/web-development/javascript/promise-for-beginners/)
