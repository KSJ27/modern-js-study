# 🚀15장. let, const 키워드와 블록 레벨 스코프

## var 키워드로 선언한 변수의 문제점

1. **변수 중복 선언을 허용한다**
   - 이미 선언되어 있는 변수의 이름을 다시 사용하여 재할당하더라도, 오류가 나지 않으므로 개발자는 알 수가 없다.

```js
console.log(a); // undefined가 출력된다
var a = 1;

var a = 3; // 중복 선언이 된다
console.log(a); // 3
```

2. **함수 레벨 스코프를 가진다**: 오직 함수의 코드 블록만을 지역 스코프로 인정하므로, 함수 외부에서 `var` 로 선언된 변수는 전역 변수가 된다.
   - 의도치 않게 전역 변수가 중복 선언되면서 남발될 수도 💢
   - 전역 변수는 불가피한 상황을 제외하고, 사용을 억제하는 것이 좋다. 스코프 (유효 범위) 가 넓고 의도치 않게 변경될 수 있어서 복잡성을 증가시키기 때문이다.

### 🤔전역객체의 프로퍼티→ `var`

왜 `var` 키워드로 전역변수가 선언되는 것이 좋지 않다고 할까 ?

전역 코드는 코드가 로드되자마자 해석되고 실행된다. 여기서 `var` 키워드로 선언한 전역 변수, 함수, 암묵적 전역 모두 전역 객체 (window) 의 프로퍼티가 된다.

> 전역 객체 ?
> 타임 이전에, JS 엔진에 의해 어떤 객체보다도 먼저 생성되는 특수한 객체로, 브라우저에서는 `window` , 서버 사이드 환경에서는 `global` 객체를 의미함

- 전역 변수의 문제점
  - 모든 코드가 전역 변수를 참조, 변경할 수 있는 암묵적 결합을 허용한다.
  - 긴 생명 주기 => 메모리 리소스를 오랜 기간 낭비
  - 스코프 체인 상 가장 상위에 존재 => 검색 시 속도가 가장 느리다.
  - 다른 파일 내 동일한 이름으로 전역 변수, 함수가 존재하면 예상치 못한 결과 초래.

```js
var burger = 5000;

for (var burger = 0; burger < 3; burger++) {
  console.log(`버거를 ${burger} 개 먹음`);
}

// 5000 출력을 의도했지만, for 문에서 재선언되었기 때문에 3이 출력됩니다
console.log(`버거 가격은 ${burger}입니다`);
```

3. **변수 호이스팅에 의해 `var` 키워드로 선언한 변수는 선언문 이전에 참조될 수 있다** (언제나 `undefined` 를 반환)
   - 에러가 나지는 않지만, 가독성을 떨어트리고 프로그램 흐름 상에도 맞지 않다 💢
   - `var` 의 선언+초기화 단계
     - 컴파일 : <u>선언단계</u>+<u>초기화 단계</u>를 한번에 진행한다.
     - 선언 : 스코프 (실행 컨텍스트의 렉시컬 환경) 에 변수 식별자를 등록해, JS 엔진에 변수 존재를 알림
     - 초기화 : 선언 즉시 `undefined` 로 변수를 초기화. => 이후 변수 할당문에 도달하면 비로소 값이 할당됨 ( `var a = 3`)
     - <u>즉, <u>스코프에 이미 변수가 존재하므로</u> 실제 선언문 이전에 접근해도 에러가 나지 않음. </u>

## let 의 등장

> 등장 배경 : `var` 키워드의 단점을 보완하기 위해 ES6 에서 등장한 새로운 변수 선언 키워드

| var 이 가졌던 문제점들                    | let 의 해결                                                                      |
| ----------------------------------------- | -------------------------------------------------------------------------------- |
| 변수 중복 선언을 허용함                   | 변수 중복 선언을 금지함                                                          |
| 함수 레벨 스코프를 가짐                   | 블록 레벨 스코프를 가짐                                                          |
| 변수 호이스팅에 의해 선언문 이전에 참조됨 | 변수 호이스팅이 일어나는 건 같으나, 선언문 이전에 참조하면<br>참조 에러가 발생함 |

1. 같은 스코프 내에서 변수의 중복 선언을 허용하지 않는다.
2. 모든 코드 블럭 (함수, if, for, while..) 을 지역 스코프로 인정하는 블록 레벨 스코프를 따른다.

```js
let i = 10; // 전역변수 i

for (let i = 0; i < 5; i++) {
  // for 문 안에서 선언된 지역변수 i
  console.log(i); // 0 1 2 3 4
}

console.log(i); // 전역변수 i (10) 을 출력
```

3. 선언 단계와 초기화 단계를 분리되어 진행한다
   → 컴파일 단계에서 JS 엔진에 의해 암묵적으로 선언 단계가 먼저 실행되지만, **초기화 단계는 변수 선언문에 도달했을 때 실행된다.**
   → 초기화 단계 이전(TDZ)에 변수에 접근하려 하면 참조 에러 (Reference Error) 가 발생한다.

> TDZ 존 : 스코프 시작지점 ~ 초기화 시작 지점까지 변수를 참조할 수 없는 구간

![400](https://i.imgur.com/n6uZBf2.png)

## const 에 대해서.

- 반드시 선언과 동시에 초기화 한다 ( X → 문법 에러)
- 블록 레벨 스코프를 가지고, 호이스팅이 발생하지 않는 것처럼 동작한다. (선언문 이전에 변수에 접근하려 하면 참조 에러)
- 재할당이 금지된 변수
- 대문자 사용, 언더 스코어 ( \_ ) 를 사용해서 스네이크 케이스로 구분
- `const` 로 선언된 변수에 객체를 할당한 경우, 객체 변경은 가능 (프로퍼티 동적 생성과 삭제, 프로퍼티 값 변경 등등)

```js
const student = {
	name : 'hani';
}
student.name = 'newJeans';
```

> 💫
> const 키워드는 변수에 재할당을 금지할 뿐, ‘불변’ 을 의미하지 않는다.

## 정리 : 변수의 키워드 선언

> 변수를 선언할 때는 우선 `const` 키워드를 사용하고, 만약 재할당이 필요하면 그 때 가서 `let` 으로 선언 키워드를 변경 해도 늦지 않다.
