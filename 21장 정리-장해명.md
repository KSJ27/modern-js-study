# 21장. 빌트인 객체

자바스크립트 객체는 세 가지 종류가 있다
: 표준 빌트인 객체, 호스트 객체, 사용자 정의 객체 (말 그대로, 사용자가 직접 정의한 객체)

- **표준 빌트인 객체** : <u>ECMAScript 사양에 정의된 객체</u>이므로, 실행환경에 영향을 받지 않고 언제나 사용할 수 있다.

  - ECMAScript 의 모든 버전에 걸쳐 정의됬다는 것.
  - 전역 객체의 프로퍼티로써 제공되는 객체들

- **호스트 객체** : 브라우저, Node.js 에서 추가로 제공하는 객체들

  - 브라우저 → 클라이언트 사이드 Web API (DOM, XMLHttpRequest)

  <img src = "https://i.imgur.com/2vdX02i.png" width = "500"/>

# 표준 빌트인 객체

자바스크립트에서 이미 정의된 객체들로, 실행환경에 구애받지 않는다.
무려 40여개가 존재하며, **생성자 함수 객체 / 생성자 함수가 아닌 객체**로 나눌 수 있다.

| 표준 빌트인 객체 종류  |     | 생성자 함수 객체        |     | 생성자 함수가 아닌 객체 |
| ---------------------- | --- | ----------------------- | --- | ----------------------- |
| **인스턴스 생성 여부** |     | O                       |     | X                       |
| **제공하는 메서드**    |     | 프로토타입, 정적 메서드 |     | 정적 메서드             |

### 생성자 함수 객체

```js
const str = new String("Lee"); // String {  "Lee" } 인스턴스
console.log(str.toUpperCase()); // "LEE" 출력
```

- **표준 빌트인 객체 (`String` ) 을 생성자로 사용하면, 생성된 인스턴스 `String { "Lee" }` 는 자동으로 해당 객체의 프로토타입 ( String.prototype ) 을 상속받는다. 즉, 여기에 정의되있는 메서드들을 모두 사용할 수 있다.**
- `String` 은 new 와 함께 호출되어, 해당 타입의 인스턴스를 만든다 : `String {  "Lee" } `
- 인스턴스는 프로토타입 체인으로 `String.prototype` 과 연결되므로, 그 안에 메서드들을 사용할 수 있다
  (생성자 함수가 생성한 인스턴스의 프로토타입은, 표준 빌트인 객체의 prototype 프로퍼티에 바인딩된 객체)

> [!Note] `prototype` 프로퍼티 ?
> 객체로 생성된 모든 인스턴스가 상속받는 메서드, 속성들이 정의되있는 프로퍼티
>
> - 예시로, `String.prototype` 에는 문자열을 조작하는 split() 과 toupperCase() 가 정의되있음

> [!Note] **주의** > `str.toUpperCase` 로 메서드를 바로 사용하고 있지만, 변수 str 자체에 이 메서드가 정의된 게 아님. 단지, 자바스크립트가 만들어진 인스턴스 (str) 의 프로토타입 체인 (상속 관계) 를 따라가서 `String.prototype` 에서 메서드를 찾는 것.

> [!Summary] 정리
> 생성자 함수로 만든 인스턴스는 자동으로 해당 객체의 prototype 을 상속받는다.
> 따라서 프로토타입 체인을 따라갈 수 있으며, 객체가 제공하는 다양한 메서드들을 사용할 수 있다.
> => 여기서 사용하는 게, 인스턴스 메서드.

### `Number` 을 예시로 보는 인스턴스 메서드와 정적 메서드의 차이

- 정적 메서드 : `new` 키워드로 객체의 인스턴스를 생성하지 않고도, 객체 자체에서 호출할 수 있는 메서드
  - 예시 ) `Number.parseInt` , `Number.isNaN` , `Math.random()` → 모두 객체 자체에서 호출하고 있지 ?
- 인스턴스 메서드 (프로토타입 메서드) : 객체의 인스턴스에서 호출한다
  - 예시 ) `Number.prototype.toFixed`

```js
// 인스턴스 메서드 코드
const num = new Number(123.456); // Number { "123.456" } 인스턴스 만듬
console.log(num.toFixed(2)); // "123.46" , 소수점 두자리로 반올림
```

이처럼 하나의 객체에서, 정적 메서드와 프로토타입 메서드가 둘다 존재할 수 있다.

# 매번 생성자 함수를 호출하지 않아도 되는 이유

```js
const season = "spring";
console.log(season.toUpperCase()); // SPRING
```

문자열, 숫자, Boolean 같은 원시값은 ‘값 자체’ 이므로 메서드나 프로퍼티를 추가할 수 없다.
위 코드에서는 `new` 연산자로 생성자 함수를 이용하지 않고, 바로 문자열 자체에 메서드를 사용하고 있다.
그런데 에러가 나지 않고, SPRING 이 출력되는 이유는 뭘까 ?

위처럼 원시값을 객체처럼 접근하면, 즉 마침표 표기법으로 접근하면
→ 자바스크립트 엔진은 원시값에서 임시 객체인 Wrapper 객체를 생성한다.
그래서 위 코드에서 안전하게 메서드도 사용할 수 있었던 것.

그럼 기존 원시값은 사라지는 걸까 ?
아니다, 그 객체의 `[[StringData]] ` 내부 슬롯에 저장된다.
(자바스크립트는 객체에 내부 슬롯이라는 특수한 공간을 가지고 있다. 직접 접근할 수는 없지만, 데이터를 저장할 수 있음)

래퍼 객체 처리가 종료되면,

1. 래퍼 객체의 내부 슬롯에 할당된 원시값으로 원래 상태를 되돌리고
2. 래퍼 객체는 가비지 컬렉션의 대상이 된다

```js
const season = "summer";
season.name = "winter";
// 처리가 끝난 래퍼 객체가 가비지 컬렉션에 들어가므로 undefined 가 출력됨
console.log(season.name); // undefined
```

> [!Summary] **정리**
> 원시값은 점 표기법을 사용해 암묵적으로 래퍼 객체를 만들어, 객체의 프로퍼티와 메서드를 사용할 수 있다.
> 따라서 `String` , `Number` , `Boolean` 생성자 함수를 `new` 키워드로 호출해 인스턴스를 만들 필요도 없고,
> 권장도 되지 않는다고 한다.

### 가비지 컬렉터 ?

> _애플리케이션이 할당한 메모리 공간을 주기적으로 검사하여 더 이상 사용되지 않는 메모리를 해제하는 기능을 말한다._ > _더 이상 사용하지 않는 메모리란, 어떤 식별자도 참조하지 않는 메모리 공간을 의미한다._ > _자바스크립트는 **가비지 컬렉터를 내장하고 있는 언어** 로써 메모리 누수를 방지한다._

# 용어 정리

### 인스턴스와 생성자 함수란 ?

- 생성자 함수 : 쿠키를 만들기 위한 틀 (설계도)
  - Number, String, Array
- 인스턴스 : 틀로 찍어서 만든 실제 쿠키 (틀의 모양을 따라가지만, 고유한 데이터를 가질 수 있음)
  - `new` 키워드로 만든 객체들 🍪

### 표준 빌트인 객체 = 생성자 함수 ??

Number , String , Math 같은 표준 빌트인 객체는 **기본적으로 생성자 함수 역할을 하면서도** + **정적 메서드와 프로퍼티를 제공하는 특수한 객체들**이라고 한다. 그리고 생성자 함수로 사용한다는 건, `new` 키워드를 사용해서 인스턴스, 즉 객체를 만드는 것.

# 전역 객체

> **코드가 실행되는 런타임 이전, 자바스크립트 엔진에 의해 가장 먼저 생성되는 최상위 객체**

### 전역 객체의 특징

1. 표준 빌트인 객체, 호스트 객체, `var` 로 선언한 전역변수/함수를 프로퍼티로 소유한다.
2. 개발자가 의도적으로 생성할 수는 없고, 참조만 할 수 있다.
3. 브라우저의 모든 자바스크립트 코드는 하나의 전역 객체인 window 를 공유한다.

`let`, `const` 로 선언한 변수라면, 전역 변수라도 전역 객체의 프로퍼티가 아니다.

### 빌트인 전역 프로퍼티 : built-in global property

```js
console.log(globalThis.Infinity); // Infinity, 무한대
console.log(globalThis.NaN); // NaN, 숫자가 아님
console.log(globalThis.undefined); // undefined, 정의되지 않음
```

- 전역 객체의 프로퍼티로, 스스로 다른 프로퍼티나 메서드를 갖지 못하고 값만 반환한다.
- (+) `globalThis` ? ES11 부터 브라우저와 Node 환경에서 전역 객체를 가리키던 다양한 식별자를 하나로 통일한 식별자. 모든 환경에서 사용할 수 있다.

### 빌트인 전역 함수

- 전역에서 호출할 수 있는 함수로, 전역 객체의 메서드를 말한다.
- 종류 : `eval` , `isFinite` , `isNaN` , `pareFloat - parseInt` , `encodURI/decodeURL` , `encodeURIComponent / decodeURIComponent`

1. `isFinite( )` : 유한수 여부 출력

```js
// 유한수이거나 유한수로 평가될 수 있으므로 true 출력
console.log(isFinite(1), isFinite("1"), isFinite(null));
// 무한수 이거나 수로 평가될 수 없는 값이므로 false 출력
console.log(isFinite(1 / 0), isFinite(NaN), isFinite("abc"));
```

2. `isNaN() ` : 숫자로 인식될 수 없으면 true 를 출력

```js
// true true true true false
console.log(isNaN(NaN), isNaN("abc"), isNaN({}), isNaN(undefined), isNaN(null));
```

- `null` 처럼 숫자 타입이 아니더라도 변환해서 평가한다.

3. `parseFloat` : 인자로 받은 값을 실수로 변환

```js
// 123.4567 123.4567 123 출력 (문자열은 앞뒤 공백 무시)
console.log(parseFloat("123.4567"), parseFloat(123.4567), parseFloat(" 123 "));
// 배열은 첫 요소가 숫자면 해당 요소만 반환 (12 출력)
console.log(parseFloat([12, 45, 67]));
// NaN 출력
console.log(parseFloat([]));
```

4. `parseInt` : 인자로 받은 값을 정수로 변환

```js
// 소수점 뒤에 오는 숫자는 버림 (모두 123 출력)
console.log(parseInt(123), parseInt("123"), parseInt(" 123.456 "));
// 두번쨰 인자 진법으로 해석해 출력 (3 출력)
console.log(parseInt("11", 2));
```

- `parseInt` 와 `parseFloat` 모두 무효한 숫자는 `NaN` 을 반환한다.
- 두번째 인자로 숫자가 오면 첫 번째 인자를 해당 진법의 숫자로 해석해 반환한다.

5. `encodeURI(url)` : 전체 URL 을 아스키문자로 인코딩할 때 사용한다

```js
const uri = "https://www.todomate.net/path?name=장해명";
console.log(encodeURI(uri));
// https://www.todomate.net/path?name=%EC%9E%A5%ED%95%B4%EB%AA%85

// 예약 문자는 인코딩하지 않음: ; , / ? : @ & = + $ #
```

- URL 구조를 위한 예약 문자 ( / , ? , : , @, = , & ) 는 인코딩하지 않는다.

6. `encodeURIComponent( )` : URL 의 파라미터 값처럼, 일부분을 인코딩할 때 사용한다 ⭐
   → 더 많이 쓰일 듯.

```js
const word = "해명";
const encodedWord = encodeURIComponent(word);
console.log(encodedWord); // %ED%95%B4%EB%AA%85
```

- 모든 특수 문자를 인코딩한다

7.  `decodeURI` , `decodeURIComponent`

- 반대로 동작한다.

---

# 참고

모던 자바스크립트 딥다이브 21장

https://velog.io/@junh0328/DEEP-DIVE-%ED%95%9C-%EC%9E%A5-%EC%9A%94%EC%95%BD-%EB%B9%8C%ED%8A%B8%EC%9D%B8-%EA%B0%9D%EC%B2%B4
https://www.yalco.kr/@javascript/6-2/
