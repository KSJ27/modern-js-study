# 제너레이터

> _코드 블럭 실행을 일시 중지했다가, 원하는 시점에 재개할 수 있는 특수한 함수_

1. 제너레이터 함수는 함수의 실행을 함수 호출자가 제어할 수 있다.
2. 제너레이터 함수는 호출자에게 상태를 전달하고, 호출자로부터 상태를 전달받을 수 있다.
3. 제너레이터 함수를 호출하면, 제너레이터 객체를 반환한다.

### 정의 방법

> `function*` 를 사용해서 선언하고, 하나 이상의 `yield` 표현식을 가지는 함수

```js
function* foo() {
  yield "안녕";
  yield "두 번째 안녕";
  yield "세 번째 안녕";
}

const gen = foo();

console.log(gen.next());
console.log(gen.next());
console.log(gen.next());
console.log(gen.next());
```

![](https://i.imgur.com/SNl1JOB.png)

- 제너레이터는 next( ) 를 호출하면 실행되고, yield 를 만나면 실행을 멈춘 뒤 value 를 반환한다.
- 더 이상 yield 가 없으면 `done: true` 가 됨

### 제너레이터 객체 : `{ value: 값, done: 상태 }`

`foo` 같은 제너레이터 함수에서 .next( ) 를 호출하면 제너레이터 객체를 반환한다.

- 형태 : `{ value: 값, done: 상태 }`
- 특징 : **Iterable 이면서 동시에 Iterator** 이다

> 🚀**Iterable 이면서 동시에 Iterator** 이다

- Iterable (이터러블)
  - 배열, 객체처럼 for..of 로 순회할 수 있는 객체
  - Symbol.iterator( ) 를 가짐
- Iterator (이터레이터)
  - `next( )` 메서드를 가지고 있어서, 호출할 때마다 `{value, done}` 객체를 반환하는 객체
  - `done: true` 가 나오기 전까지 계속 `next()` 를 호출할 수 있음

> 🔔**제너레이터 객체가 이터러블 + 이터레이터라고 하는 이유**
> 이터러블이므로 `for .. of` 를 사용할 수 있고,
> 동시에 `.next( )` 를 사용해 값을 하나씩 반환할 수 있기 때문이다

### return(value ) 과 throw(error)

> 제너레이터 함수는 yield 표현식이 남아있는 한, next( ) 를 호출하면 계속 실행될 수 있지만 ..

- return(value) : 제너레이터 실행을 강제로 종료시키는 메서드
  - 위 코드에서 `console.log(gen.return(“종료”))` → `{ value: '종료', done: true }`
  - 이후 next( ) 를 호출해도 더 이상 값이 나오지 않음 = `value : undefined`
- throw(error) : 제너레이터 실행 도중 강제로 에러를 발생시키는 메서드 - try..catch 로 예외를 잡을 수 있음
  ![](https://i.imgur.com/bpLZyUM.png)

### 제너레이터의 yield 와 next

1. 제너레이터 객체의 next( ) 를 호출하면 yield 표현식까지 실행되고 일시 중지됨 (suspend)
   => 이를 함수의 제어권이 호출자로 양도되었다고 함
2. 이후 호출자가 다시 next( ) 를 호출하면 **일시 중지된 코드로부터 실행을 재개함** (resume)
3. 다시 yield 표현식까지 실행되고, 또 다시 일시 중지됨

> 🚀 **`next( )`가 반환하는 Iterator Result 객체 `{value : , done: }**

- `value` : yield 표현식에서 yield 된 값
- `done` : 제너레이터 함수가 끝까지 실행되었는지 보여주는 불리언 값

> 🚀 **제너레이터 함수가 호출자와 상태를 주고받는다는 것**

![](https://i.imgur.com/DXXZGQO.png)

실행 흐름을 따라가보자.

1. gen.next()
   - 제너레이터가 처음 실행된다.
   - `yield 1;` 을 만나 실행을 멈추고, `{ value: 1, done: false }`를 반환한다.
   - **이 시점에서 제너레이터 내부 상태 (중요)**

```js
const x = yield 1; // 여기서 멈춤 (x는 아직 할당되지 않음)
```

2. gen.next(10)
   - 이전 `yield` 에서 멈춘 부분에 10을 전달하면서, 실행을 재개한다.
   - `yield 1` → `10` 으로 대체되고, `const x = 10` 이 된다.
   - `yield 10+10` → `yield 20` 에서 실행을 멈추고, `{ value: 20, done: false }` 를 반환한다.
   - **이 시점에서 제너레이터 내부 상태**

```js
const y = yield 20; // 여기서 멈춤 (y는 아직 할당되지 않음)
```

3. gen.next(20)
   - 이전 `yield` 에서 멈춘 부분에 20을 전달하면서, 실행을 재개한다.
   - `yield 20` → `20` 으로 대체되고, `const y = 20` 이 된다.
   - `return 10+20` 에서 `30` 이 반횐되고, 제너레이터가 종료된다.

### 제너레이터의 활용

> _제너레이터 함수를 이용해서 iterable 을 구현하거나,_
> _`then/catch/finally` 등 후속 처리 메서드 없이도 Promise 비동기 처리를 해줄 수 있다._
> → 단점 : 코드가 장황해지고 가독성이 좋지 않음

# async 와 await (ES8)

> 제너레이터보다 간단하게, 비동기 처리를 동기 처리처럼 동작하게 구현한 방법

- Promise 를 기반으로 동작하지만, `then/catch/finally` 등 후속 처리 메서드 없이도 비동기 작업을 동기적으로 보이게 처리할 수 있는 방법

### 🚀 async

- `async( )` 는 `async` 키워드로 정의하고, 언제나 `Promise` 를 반환한다
  - `Promise.resolve(값)` 으로 감싸진 `Promise` 가 항상 반환된다는 뜻.

![](https://i.imgur.com/O1JUFeS.png)
→ 일반 함수는 값을 반환하지만, `async` 함수는 `Promise` 객체를 반환한다.

- 그래서 인스턴스를 반환하는 클래스의 생성자 함수는, 유일하게 `async` 함수가 될 수 없다.

### 🚀 await

- `Promise` 가 `settled` 상태가 될 때까지 대기하다가, `settled` 가 되면 _Promise 가 resolve 한_ 처리 결과를 반환한다.
- `await` 키워드는 반드시 `Promise` 앞에서 사용해야 하지만, <u>모든 Promise 앞에 무분별하게 사용하는 것은 지양해야 한다.</u>

- 서로 연관 없이, 개별적으로 실행되는 `Promise` → `Promise.all()` 을 사용하면 `await` 을 한번만 사용할 수 있음
- 그러나 앞선 비동기 처리 결과를 가지고 다음 비동기 처리를 실행하는 작업이라면 : 각각 `await` 을 사용해 순차적으로 처리해야 함.

# async/await 의 에러 처리

> async/await 는 에러 처리를 try..catch 문으로 할 수 있다

### 🚀 기존 비동기 처리를 위한 콜백 패턴 : try-catch 문을 사용할 수 없음

> (콜백 함수를 인수로 받는 비동기 함수)

```js fold title="콜백함수를 인수로 받는 비동기함수"
// 나중에 콜백 함수가 실행될 때 결과를 받는 방식
// 에러 처리를 하려면 콜백 내부에서 다시 작성해야 함
try {
  setTimeout(() => {
    throw new Error("에러");
  }, 1000);
} catch (e) {
  // 에러를 캐치하지 못함
  console.error(e);
}
```

### 🚀 async/await : try-catch 문을 사용할 수 있음

- `Promise` 를 반환하는 비동기 함수는 명시적으로 호출할 수 있으므로, 호출자가 명확하다.
  (에러는 호출자 방향으로 전파됨)
- 즉, `try-catch` 로 에러를 처리 할 수 있다.

> 🔔 중요
>
> - `async` 함수는 항상 `Promise` 를 반환한다.
> - `await` 은 `Promise` 가 성공하면 (`resolve`) 결과를 반환하고, 실패 (`reject` ) 하면 예외 (`throw`) 를 발생시킨다 → `try..catch` 로 예외 처리를 해줄 수 있다.

### 🌐 await 의 역할

![](https://i.imgur.com/uOO0Ijr.png)

- `async bar( )` 이 실행되면, `Promise.reject(error)` 을 반환한다
  - 정확하게는, `Promise { <rejected> Error: bar( ) 에서 에러 }`
- `await bar` 에서 `await` 은, 이를 `throw error` 처럼 동작시킨다
- 결국, `catch` 문에서 이를 잡아 에러 처리를 할 수 있다.

- 그래서 async 함수 내에서 catch 문을 사용해서 에러 처리를 하거나,
  async 함수 외에서 .`catch()` (프로미스 후속 처리 메서드) 를 사용해 에러를 캐치할 수 있다.
