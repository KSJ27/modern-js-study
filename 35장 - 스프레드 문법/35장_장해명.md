# 35. 스프레드 문법
> 배열과 같은 이터러블을 펼쳐서 (spread) 개별적인 값들의 목록으로 만드는 문법
- 이터러블 : 배열, 문자열, Map, Set, DOM 컬렉션처럼  `Symbol.iterator` 을 상속받고, `for..of` 문으로 순회할 수 있는 객체
- 스프레드 문법의 결과는 값이 아니므로, 변수에 할당할 수 없다. 
```js
const list = ...[1,2,3]; // SyntaxError
```

### 스프레드 문법의 활용
1. 함수 호출문의 인수 목록에서 사용하는 경우 
2. 배열 리터럴 내부에서 사용하는 경우 
3. 객체 리터럴 내부에서 사용하는 경우

### 함수 호출문 인수 목록에서 사용하는 경우 
```js
// 배열에서 최댓값을 구하시오
const arr = [1,2,3]; 
const max = Math.max(...arr); 
```
- Math.max( ) 는 개수가 정해져있지 않은 여러 숫자를 인수로 전달받아, 최대값을 반환한다. 
	- 배열과 함께 사용할 때 스프레드 문법을 사용해 배열을 펼쳐준다. 

- 주의 : **Rest 파라미터**도 `...` 를 사용하지만, **전달받은 인수들을 하나의 배열로 모으는 문법**이다. 
```js
function sum(...numbers) {
  // 1,2,3,4,5 -> [1,2,3,4,5]
  let sum = 0;
  numbers.forEach((num) => {
    sum += num;
  });
  return sum;
}

console.log(sum(1, 2, 3, 4));
```

>Rest 파라미터는 여러 값을 하나의 배열로 모으는 문법이고, 
>Spread 문법은 배열 같은 객체를 여러 개로 펼치는 문법이다. 

### 배열 리터럴 내부에서 사용하는 경우
> = 배열을 생성할 때 사용하는 경우 

1. 배열을 합칠 때 `concat( )` 대신 사용함
```js
const arr1 = [1, 2, 3];
const arr2 = [...arr1, 4, 5];
console.log(arr2); // [ 1, 2, 3, 4, 5 ]
```

2. 배열 중간에 다른 배열 요소들을 추가/제거할 때 `splice` 와 함께 사용함
```js
let arr1 = [1, 4];
let arr2 = [2, 3];
arr1.splice(1, 0, ...arr2); // arr1 의 1번째 인덱스에 삭제하는 요소 없이, arr2 요소를 삽입
console.log(arr1); // [ 1, 2, 3, 4 ]
```
- 참고 : `splice( )` 사용법
	```js
	// 배열을 직접 변경하는 메서드
	// 배열의 특정 위치에 있는 요소를 제거하거나, 새 요소를 추가할 때 사용함
	arr.splice(startIndex, deleteCount, item,...);
```

3. 배열을 복사할 때 `slice` 대신 사용함
```js
let origin = [1, 2, 3];
let copySlice = origin.slice();
console.log(copySlice); // [[ 1, 2, 3 ]

let copySpread = [...origin];
console.log(copySpread); // [[ 1, 2, 3 ]
```
- 공통점 : 둘다 얕은 복사 (데이터 자체가 아닌, 메모리 주소를 복사함)
	- *복사된 객체 속성이 원본 객체와 같은 참조값을 가지는 복사*
- slice( ) 는 원본 배열을 수정하지 않고, 새 배열을 반환한다고 함

4. 이터러블을 배열로 변환하기
- `arguments` : 함수를 호출할 때 넘긴 모든 인수들이 자동으로 `arguments` 로 저장되므로, 함수 안에 사용하면 매개변수 선언 없이도 전달된 값을 다를 수 있다. 
```js
// arguments 객체는 유사 배열 객체 
const foo = () => {
  console.log(arguments);
};

foo(1, 2, 3);
```

- `arguments` 는 유사 배열 객체이므로 배열 메서드 (map, reduce) 를 직접 사용할 수 없다 
	- 유사 배열 객체 : `length` 속성을 가지고, index 로 요소를 저장하지만, 배열 메서드를 직접 사용할 수 없는 객체

![300](https://i.imgur.com/TVb76h5.png)

**기존 ES5 방식 : `.slice.call( )` 로 배열로 변환하기**
```js
function sum() {
  let args = Array.prototype.slice.call(arguments); // arguments를 배열로 변환
  return args.reduce((pre, cur) => pre + cur, 0);
}

console.log(sum(1, 2, 3)); // 6
```

**스프레드 문법 이용하기** : arguments 는 이터러블이면서 유사배열 객체
```js
function sum() {
  return [...arguments].reduce((pre, cur) => pre + cur, 0);
}

console.log(sum(1, 2, 3)); // 6
```

**Rest 파라미터 사용하기 (추천)**
```js
function sum(...args) {
  return args.reduce((pre, cur) => pre + cur, 0);
}

console.log(sum(1, 2, 3)); // 6
```

>[!Note] 모든 유사 배열 객체에 스프레드 문법을 사용할 수 있는가 ?
> X , 이터러블이면서 유사배열 객체여야 사용할 수 있다.
> 이터러블이 아닌 유사 배열 객체를 배열로 변환할 때는 `Array.from( )` 을 사용한다. 

### 객체 리터럴 내부에서 사용하는 경우
> *스프레드 프로퍼티 제안 : 일반 객체를 대상으로도 스프레드 문법 사용을 허용함*
```js
const merged = { ...{ a: 1, b: 2 }, ...{ b: 3, c: 4 } };
console.log(merged); // { a: 1, b: 3, c: 4 }
```
- 이전 :  객체를 복사하거나 병합할 때 `Object.assign( {}, obj )` 을 사용한다
	- 스프레드 문법보다 성능이 상대적으로 느림
- 스프레드 문법과 `Object.assign( )` 모두 얕은 복사이므로, 중첩된 객체는 참조만 복사한다.

> 🚀 **Object.assign( ) 를 사용하는 경우**
> 1. getter/setter 을 유지하고 2. null 과 undefined 이 포함되는 경우 (에러 발생 X)


